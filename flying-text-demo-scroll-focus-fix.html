<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Floating Text Relay · Scroll Focus Locked</title>
    <style>
      :root {
        --bg: #0b1020;
        --panel: rgba(255, 255, 255, 0.06);
        --border: rgba(255, 255, 255, 0.12);
        --text: #e9edff;
        --muted: rgba(233, 237, 255, 0.72);
        --accent: rgba(122, 162, 255, 0.3);
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        min-height: 100vh;
        background: var(--bg);
        color: var(--text);
        font-family: system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", Arial;
        overflow: hidden;
      }
      .wrap {
        height: 100vh;
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 14px;
        padding: 18px;
      }
      header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
        padding: 12px 14px;
        border: 1px solid var(--border);
        background: var(--panel);
        border-radius: 16px;
        backdrop-filter: blur(10px);
      }
      .title { font-weight: 850; letter-spacing: 0.2px; margin-bottom: 4px; }
      .hint { color: var(--muted); font-size: 13px; line-height: 1.35; max-width: 80ch; }
      button {
        background: var(--text);
        color: #0b1020;
        border: 0;
        border-radius: 12px;
        padding: 10px 14px;
        font-weight: 850;
        cursor: pointer;
        white-space: nowrap;
      }
      button:disabled { opacity: 0.6; cursor: not-allowed; }

      .stack {
        display: grid;
        gap: 14px;
        height: 100%;
        overflow-y: auto;
        padding-right: 6px;
        scroll-snap-type: y proximity;
      }
      .panel {
        position: relative;
        border: 1px solid var(--border);
        background: var(--panel);
        border-radius: 18px;
        padding: 16px 18px 18px;
        overflow: hidden;
        min-height: 260px;
        scroll-snap-align: center;
        transition: border-color 0.25s ease, box-shadow 0.25s ease;
      }
      .panel--active {
        border-color: rgba(122, 162, 255, 0.7);
        box-shadow: 0 0 0 2px var(--accent);
      }
      .panel h2 {
        margin: 0 0 10px 0;
        font-size: 14px;
        letter-spacing: 0.3px;
        color: var(--muted);
        font-weight: 750;
        display: flex;
        justify-content: space-between;
        gap: 10px;
        align-items: center;
      }
      .badge {
        font-size: 12px;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        color: var(--muted);
        background: rgba(255, 255, 255, 0.04);
      }
      .article {
        position: relative;
        font-size: 15.5px;
        line-height: 1.75;
        letter-spacing: 0.2px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      /* 关键：不再用 display:none 之类影响布局测量，仍可用 opacity 让它“不可见但可测量” */
      .article--hidden {
        opacity: 0;
        pointer-events: none;
      }

      .tok {
        display: inline-block;
        position: relative;
        will-change: transform, opacity;
      }

      #flyLayer {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 9999;
      }
      .flying-token {
        position: absolute;
        display: inline-block;
        white-space: pre;
        font-size: 15.5px;
        line-height: 1.75;
        letter-spacing: 0.2px;
        font-family: system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", Arial;
        color: var(--text);
        will-change: transform, opacity;
        transform: translateZ(0);
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <header>
        <div>
          <div class="title">Floating Text Relay: Scroll Focus Locked (1 → 6)</div>
          <div class="hint">
            ✅ 滚动过程中不会空屏；等滚动稳定后才测量并飞行，避免“凭空起飞/瞬移”。
            ✅ 手动回滚/滚动会自动取消当前动画并重新锁定 active，仍可继续运行。
          </div>
        </div>
        <button id="go">Advance Panel</button>
      </header>

      <div class="stack" id="panelStack"></div>
    </div>

    <div id="flyLayer"></div>

    <script>
      const ARTICLES = [
        {
          title: 'Article One · Before Dawn',
          text: `Before dawn, the city feels like a workshop still warming up.
The sky is a dark canvas, and a thin ribbon of light edges the rooftops.
I walk slowly, noticing how coffee steam coils upward like a promise.
The quiet is not empty; it is a room full of breathing, engines, and memory.

I write in my notebook about patience, about learning to pace my attention.
Even a small routine can be a compass: stretch, sip, breathe, then begin.
Progress rarely shouts. It whispers, and you must listen carefully.
There is a discipline in the soft moments, and a courage in continuing.

In the end, I keep one sentence close:
move with intention, and let today be kind to tomorrow.`,
        },
        {
          title: 'Article Two · Midday',
          text: `By midday, the light is sharper, and the streets feel alive.
The same buildings now cast shorter shadows, and every surface hums with heat.
I pause to watch a cyclist glide past, steady, focused, and unhurried.
The quiet of morning becomes a rhythm of footsteps, questions, and replies.

I jot a reminder: clarity grows when we focus on one honest task at a time.
A schedule is not a cage; it can be a map that protects attention.
We do not need to race; we need to keep choosing the next right step.
There is energy in consistency, and a deeper kindness in finishing well.

So I breathe, reset, and keep moving:
stay curious, stay grounded, and trust the slow build.`,
        },
        {
          title: 'Article Three · Nightfall',
          text: `At night, the city softens, and the windows turn into quiet lanterns.
The air cools, and the day folds itself into a gentler pace.
I read a few pages, hearing the steady tick of time like a calm metronome.
The questions of the morning are still there, but they no longer feel heavy.

I write another note: rest is not a reward, it is part of the work.
We carry our efforts forward best when we allow ourselves to recover.
The future is shaped by ordinary evenings, by small choices made gently.
There is grace in ending the day without rushing to the next one.

And before sleep, I set a simple intention:
keep the light on inside, and meet tomorrow with steady hope.`,
        },
        {
          title: 'Article Four · First Light',
          text: `The next morning arrives with a quiet clarity.
A pale sun warms the edges of the room, and the day feels possible again.
I open the window, letting the breeze rinse the air and the mind.
There is a kindness in returning to the basics: water, light, and a clean desk.

I make a list that is short and honest.
One careful task, one brave conversation, one note of gratitude.
The world does not demand perfection; it asks for presence.
Even a small promise kept can lift the weight of uncertainty.

I remind myself to move steadily:
soft steps, clear focus, and a willingness to begin.`,
        },
        {
          title: 'Article Five · Afternoon Drift',
          text: `Later, the afternoon stretches like a long hallway.
Time feels elastic, expanding around the things we choose to notice.
I catch the scent of rain in the distance and the sound of a closing door.
The moment is ordinary, but it is stitched with quiet meaning.

I review what has been done and what still needs care.
Momentum is built from small nudges, not dramatic leaps.
When doubt arrives, I answer with a simple action.
The work continues, and I continue with it.

I keep a phrase close at hand:
let the next step be enough for now.`,
        },
        {
          title: 'Article Six · Evening Resolve',
          text: `By evening, the light softens into amber and blue.
The day settles into a slower rhythm, the kind that allows reflection.
I tidy the space, noting the small tools and notes that guided the hours.
There is quiet satisfaction in putting things back with care.

I write a final line for the day: the path is made by walking.
We learn by showing up, by making room for rest, and by returning.
Each close is also a preparation for the next opening.
Hope is not loud; it is consistent.

So I end the day with a clear vow:
show up tomorrow with patience and steady courage.`,
        },
      ];

      const stack = document.getElementById('panelStack');
      const btn = document.getElementById('go');
      const flyLayer = document.getElementById('flyLayer');

      const panels = [];
      const T_FLY = 1200;
      const EASE_MOVE = 'cubic-bezier(.22,.61,.36,1)';

      let activeIndex = 0;
      let locked = false;

      // 保存正在飞行的动画，便于回滚/手动滚动时取消
      let runningAnims = new Set();
      let scrollWatchRAF = 0;

      function tokenizeCharLevel(text) {
        const out = [];
        for (let i = 0; i < text.length; i += 1) out.push(text[i]);
        return out;
      }

      function render(container, text) {
        container.innerHTML = '';
        const tokens = tokenizeCharLevel(text);
        for (const token of tokens) {
          const span = document.createElement('span');
          span.className = 'tok';
          span.textContent = token;
          span.dataset.tok = token;
          container.appendChild(span);
        }
      }

      function tagOccurrences(container) {
        const seen = new Map();
        container.querySelectorAll('.tok').forEach((node) => {
          const t = node.dataset.tok;
          const n = (seen.get(t) || 0) + 1;
          seen.set(t, n);
          node.dataset.key = `${t}#${n}`;
        });
      }

      function measure(container) {
        const map = new Map();
        container.querySelectorAll('.tok').forEach((node) => {
          map.set(node.dataset.key, node.getBoundingClientRect());
        });
        return map;
      }

      function clearAnimations(el) {
        try {
          el.getAnimations({ subtree: true }).forEach((a) => a.cancel());
        } catch (_) {}
      }

      function cleanupFlyLayer() {
        // 取消 clone 的动画并清空层
        runningAnims.forEach((a) => {
          try { a.cancel(); } catch (_) {}
        });
        runningAnims.clear();
        flyLayer.innerHTML = '';
      }

      function resetInlineStyles(articleEl) {
        articleEl.querySelectorAll('.tok').forEach((node) => {
          node.style.opacity = '';
          node.style.transform = '';
          node.style.filter = '';
          node.style.willChange = '';
        });
      }

      function showOnly(index) {
        // 只隐藏“非 active”的文章（但保留布局可测量）
        panels.forEach((p, i) => {
          if (i === index) p.article.classList.remove('article--hidden');
          else p.article.classList.add('article--hidden');
        });
      }

      function setActive(index) {
        panels.forEach((panel, idx) => {
          if (idx === index) {
            panel.panel.classList.add('panel--active');
            panel.badge.textContent = 'Active';
          } else {
            panel.panel.classList.remove('panel--active');
            panel.badge.textContent = 'Idle';
          }
        });
      }

      function createFlyingToken(text, startBox) {
        const el = document.createElement('div');
        el.className = 'flying-token';
        el.textContent = text;
        el.style.left = `${startBox.left}px`;
        el.style.top = `${startBox.top}px`;
        el.style.opacity = '1';
        flyLayer.appendChild(el);
        return el;
      }

      function animateFlyingToken(el, startBox, endBox) {
        const dx = endBox.left - startBox.left;
        const dy = endBox.top - startBox.top;
        const anim = el.animate(
          [
            { transform: 'translate(0,0)', opacity: 1 },
            { transform: `translate(${dx}px, ${dy}px)`, opacity: 1 },
          ],
          { duration: T_FLY, easing: EASE_MOVE, fill: 'both' }
        );
        runningAnims.add(anim);
        anim.finished.finally(() => runningAnims.delete(anim));
        return anim;
      }

      function landingInstant(targetNode, flyingClone) {
        targetNode.style.opacity = '1';
        targetNode.style.willChange = '';
        try { flyingClone.remove(); } catch (_) {}
      }

      // 等待滚动稳定（避免“滚动中测量导致瞬移/凭空飞行”）
      function waitScrollSettled(scroller, { idleMs = 120, maxMs = 1800 } = {}) {
        return new Promise((resolve) => {
          const start = performance.now();
          let lastTop = scroller.scrollTop;
          let lastMoveAt = performance.now();

          const tick = () => {
            const now = performance.now();
            const top = scroller.scrollTop;

            if (top !== lastTop) {
              lastTop = top;
              lastMoveAt = now;
            }

            if (now - lastMoveAt >= idleMs) return resolve(true);
            if (now - start >= maxMs) return resolve(false);

            scrollWatchRAF = requestAnimationFrame(tick);
          };

          cancelAnimationFrame(scrollWatchRAF);
          scrollWatchRAF = requestAnimationFrame(tick);
        });
      }

      function transition(fromArticle, toArticle) {
        cleanupFlyLayer();

        clearAnimations(fromArticle);
        clearAnimations(toArticle);
        resetInlineStyles(fromArticle);
        resetInlineStyles(toArticle);

        // 必须保证二者都“可测量”
        fromArticle.classList.remove('article--hidden');
        toArticle.classList.remove('article--hidden');

        tagOccurrences(fromArticle);
        tagOccurrences(toArticle);

        const first = measure(fromArticle);
        const last = measure(toArticle);

        // 让 from 的 token 先隐藏（保留文本布局不变）
        fromArticle.querySelectorAll('.tok').forEach((node) => {
          node.style.opacity = '0';
        });

        // to 的 token 飞入：起点 firstBox，终点 lastBox
        toArticle.querySelectorAll('.tok').forEach((node) => {
          const key = node.dataset.key;
          const firstBox = first.get(key);
          const lastBox = last.get(key);

          if (firstBox && lastBox) {
            node.style.opacity = '0';
            node.style.willChange = 'opacity';

            const clone = createFlyingToken(node.textContent, firstBox);
            const flyAnim = animateFlyingToken(clone, firstBox, lastBox);

            flyAnim.finished
              .then(() => landingInstant(node, clone))
              .catch(() => {
                try { clone.remove(); } catch (_) {}
                node.style.opacity = '1';
              });
          } else {
            // 没匹配到的字符直接显示
            node.style.opacity = '1';
          }
        });

        // 飞行完成后，回到“只显示 active”
        setTimeout(() => {
          cleanupFlyLayer();
          showOnly(activeIndex);
        }, T_FLY + 40);
      }

      function lockUI(isLock) {
        locked = isLock;
        btn.disabled = isLock;
        // 不再强制 overflow hidden（否则某些浏览器 smooth scroll 期间测量更怪）
        // stack.style.overflowY = isLock ? 'hidden' : 'auto';
      }

      // 根据视口中心找“当前最居中 panel”，用于回滚/手动滚动后恢复状态
      function findCenteredPanelIndex() {
        const stackRect = stack.getBoundingClientRect();
        const centerY = stackRect.top + stackRect.height / 2;

        let bestIdx = 0;
        let bestDist = Infinity;

        panels.forEach((p, i) => {
          const r = p.panel.getBoundingClientRect();
          const cy = r.top + r.height / 2;
          const d = Math.abs(cy - centerY);
          if (d < bestDist) {
            bestDist = d;
            bestIdx = i;
          }
        });

        return bestIdx;
      }

      // 手动滚动/回滚：取消动画并重新锁定 active（确保还能继续点击运行）
      let userScrollTimer = 0;
      stack.addEventListener('scroll', () => {
        if (locked) return;

        // 用户滚动就取消飞行，避免“飞行中位置变化”导致视觉穿帮
        cleanupFlyLayer();

        clearTimeout(userScrollTimer);
        userScrollTimer = setTimeout(() => {
          const idx = findCenteredPanelIndex();
          activeIndex = idx;
          setActive(idx);
          showOnly(idx);
        }, 90);
      }, { passive: true });

      // 渲染面板
      ARTICLES.forEach((article, index) => {
        const section = document.createElement('section');
        section.className = 'panel';

        const heading = document.createElement('h2');
        const title = document.createElement('span');
        title.textContent = article.title;
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = index === 0 ? 'Active' : 'Idle';
        heading.append(title, badge);

        const content = document.createElement('div');
        content.className = 'article';
        render(content, article.text);

        section.append(heading, content);
        stack.appendChild(section);

        panels.push({ panel: section, badge, article: content });
      });

      // 初始：只显示第一个
      setActive(0);
      showOnly(0);

      btn.addEventListener('click', async () => {
        if (locked) return;
        lockUI(true);

        cleanupFlyLayer();

        const fromIndex = activeIndex;
        const nextIndex = (activeIndex + 1) % panels.length;

        const fromPanel = panels[fromIndex];
        const toPanel = panels[nextIndex];

        // 滚动期间：from 可见；to 可见但 token 透明（避免滚动时空屏 + 避免重复显示）
        panels.forEach((p, i) => {
          p.article.classList.add('article--hidden');
          resetInlineStyles(p.article);
        });

        fromPanel.article.classList.remove('article--hidden');
        toPanel.article.classList.remove('article--hidden');

        // 先把 to 的 token 全透明（但保持布局存在，方便 scroll + 之后测量）
        toPanel.article.querySelectorAll('.tok').forEach((n) => (n.style.opacity = '0'));

        // 设置 active（高亮框跟着目标走）
        activeIndex = nextIndex;
        setActive(nextIndex);

        // 先滚动到目标
        toPanel.panel.scrollIntoView({ behavior: 'smooth', block: 'center' });

        // 关键：等滚动稳定后再测量并开始飞行
        await waitScrollSettled(stack, { idleMs: 120, maxMs: 2000 });

        // 再飞
        transition(fromPanel.article, toPanel.article);

        // 解锁（允许用户滚动/回滚）
        // 飞行期间也允许滚动，但用户滚动会自动 cancel 并恢复 active
        setTimeout(() => lockUI(false), 60);
      });
    </script>
  </body>
</html>
